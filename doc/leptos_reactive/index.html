<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The reactive system for the Leptos Web framework."><title>leptos_reactive - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="leptos_reactive" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (bf9a1c8a1 2023-10-08)" data-channel="nightly" data-search-js="search-5f5ec5419eadd0c9.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../leptos_reactive/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../leptos_reactive/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate leptos_reactive</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.5.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">leptos_reactive</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/leptos_reactive/lib.rs.html#1-152">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The reactive system for the <a href="https://docs.rs/leptos/latest/leptos/">Leptos</a> Web framework.</p>
<h3 id="fine-grained-reactivity"><a href="#fine-grained-reactivity">Fine-Grained Reactivity</a></h3>
<p>Leptos is built on a fine-grained reactive system, which means that individual reactive values
(“signals,” sometimes known as observables) trigger the code that reacts to them (“effects,”
sometimes known as observers) to re-run. These two halves of the reactive system are inter-dependent.
Without effects, signals can change within the reactive system but never be observed in a way
that interacts with the outside world. Without signals, effects run once but never again, as
there’s no observable value to subscribe to.</p>
<p>Here are the most commonly-used functions and types you’ll need to build a reactive system:</p>
<h4 id="signals"><a href="#signals">Signals</a></h4>
<ol>
<li><em>Signals:</em> <a href="signal_prelude/fn.create_signal.html" title="fn leptos_reactive::signal_prelude::create_signal"><code>create_signal</code></a>, which returns a (<a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>) tuple, or <a href="signal_prelude/fn.create_rw_signal.html" title="fn leptos_reactive::signal_prelude::create_rw_signal"><code>create_rw_signal</code></a>, which returns
a signal <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a> without this read-write segregation.</li>
<li><em>Derived Signals:</em> any function that relies on another signal.</li>
<li><em>Memos:</em> <a href="signal_prelude/prelude/fn.create_memo.html" title="fn leptos_reactive::signal_prelude::prelude::create_memo"><code>create_memo</code></a>, which returns a <a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>.</li>
<li><em>Resources:</em> <a href="fn.create_resource.html" title="fn leptos_reactive::create_resource"><code>create_resource</code></a>, which converts an <code>async</code> <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> into a
synchronous <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> signal.</li>
<li><em>Triggers:</em> <a href="fn.create_trigger.html" title="fn leptos_reactive::create_trigger"><code>create_trigger</code></a>, creates a purely reactive <a href="struct.Trigger.html" title="struct leptos_reactive::Trigger"><code>Trigger</code></a> primitive without any associated state.</li>
</ol>
<h4 id="effects"><a href="#effects">Effects</a></h4>
<ol>
<li>Use <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a> when you need to synchronize the reactive system
with something outside it (for example: logging to the console, writing to a file or local storage)</li>
<li>The Leptos DOM renderer wraps any <a href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn"><code>Fn</code></a> in your template with <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a>, so
components you write do <em>not</em> need explicit effects to synchronize with the DOM.</li>
</ol>
<h4 id="example"><a href="#example">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>leptos_reactive::<span class="kw-2">*</span>;

<span class="comment">// creates a new reactive runtime
// this is omitted from most of the examples in the docs
// you usually won&#39;t need to call it yourself
</span><span class="kw">let </span>runtime = create_runtime();
<span class="comment">// a signal: returns a (getter, setter) pair
</span><span class="kw">let </span>(count, set_count) = create_signal(<span class="number">0</span>);

<span class="comment">// calling the getter gets the value
// can be `count()` on nightly
</span><span class="macro">assert_eq!</span>(count.get(), <span class="number">0</span>);
<span class="comment">// calling the setter sets the value
// can be `set_count(1)` on nightly
</span>set_count.set(<span class="number">1</span>);
<span class="comment">// or we can mutate it in place with update()
</span>set_count.update(|n| <span class="kw-2">*</span>n += <span class="number">1</span>);

<span class="comment">// a derived signal: a plain closure that relies on the signal
// the closure will run whenever we *access* double_count()
</span><span class="kw">let </span>double_count = <span class="kw">move </span>|| count.get() * <span class="number">2</span>;
<span class="macro">assert_eq!</span>(double_count(), <span class="number">4</span>);

<span class="comment">// a memo: subscribes to the signal
// the closure will run only when count changes
</span><span class="kw">let </span>memoized_triple_count = create_memo(<span class="kw">move </span>|<span class="kw">_</span>| count.get() * <span class="number">3</span>);
<span class="comment">// can be `memoized_triple_count()` on nightly
</span><span class="macro">assert_eq!</span>(memoized_triple_count.get(), <span class="number">6</span>);

<span class="comment">// this effect will run whenever `count` changes
</span>create_effect(<span class="kw">move </span>|<span class="kw">_</span>| {
    <span class="macro">println!</span>(<span class="string">&quot;Count = {}&quot;</span>, count.get());
});

<span class="comment">// disposes of the reactive runtime
</span>runtime.dispose();</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.SpecialNonReactiveZone"><code>pub use diagnostics::SpecialNonReactiveZone;</code></div></li><li><div class="item-name" id="reexport.SharedContext"><code>pub use hydration::SharedContext;</code></div></li><li><div class="item-name" id="reexport.untrack_with_diagnostics"><code>pub use runtime::untrack_with_diagnostics;</code></div></li><li><div class="item-name" id="reexport.GlobalSuspenseContext"><code>pub use suspense::<a class="struct" href="suspense/struct.GlobalSuspenseContext.html" title="struct leptos_reactive::suspense::GlobalSuspenseContext">GlobalSuspenseContext</a>;</code></div></li><li><div class="item-name" id="reexport.SuspenseContext"><code>pub use suspense::<a class="struct" href="suspense/struct.SuspenseContext.html" title="struct leptos_reactive::suspense::SuspenseContext">SuspenseContext</a>;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="callback/index.html" title="mod leptos_reactive::callback">callback</a>::*;</code></div></li><li><div class="item-name"><code>pub use <a class="mod" href="oco/index.html" title="mod leptos_reactive::oco">oco</a>::*;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="callback/index.html" title="mod leptos_reactive::callback">callback</a></div><div class="desc docblock-short">Callbacks define a standard way to store functions and closures. They are useful
for component properties, because they can be used to define optional callback functions,
which generic props don’t support.</div></li><li><div class="item-name"><a class="mod" href="oco/index.html" title="mod leptos_reactive::oco">oco</a></div><div class="desc docblock-short">This module contains the <code>Oco</code> (Owned Clones Once) smart pointer,
which is used to store immutable references to values.
This is useful for storing, for example, strings.</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod leptos_reactive::prelude">prelude</a></div><div class="desc docblock-short">This prelude imports all signal types as well as all signal
traits needed to use those types.</div></li><li><div class="item-name"><a class="mod" href="signal_prelude/index.html" title="mod leptos_reactive::signal_prelude">signal_prelude</a></div><div class="desc docblock-short">This prelude imports all signal types as well as all signal
traits needed to use those types.</div></li><li><div class="item-name"><a class="mod" href="suspense/index.html" title="mod leptos_reactive::suspense">suspense</a></div><div class="desc docblock-short">Types that handle asynchronous data loading via <code>&lt;Suspense/&gt;</code>.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.update.html" title="macro leptos_reactive::update">update</a></div><div class="desc docblock-short">Provides a simpler way to use
<a href="signal_prelude/trait.SignalUpdate.html#tymethod.update" title="method leptos_reactive::signal_prelude::SignalUpdate::update"><code>SignalUpdate::update</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.update_value.html" title="macro leptos_reactive::update_value">update_value</a></div><div class="desc docblock-short">Provides a simpler way to use
<a href="struct.StoredValue.html#method.update_value" title="method leptos_reactive::StoredValue::update_value"><code>StoredValue::update_value</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.with.html" title="macro leptos_reactive::with">with</a></div><div class="desc docblock-short">Provides a simpler way to use <a href="signal_prelude/trait.SignalWith.html#tymethod.with" title="method leptos_reactive::signal_prelude::SignalWith::with"><code>SignalWith::with</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.with_value.html" title="macro leptos_reactive::with_value">with_value</a></div><div class="desc docblock-short">Provides a simpler way to use
<a href="struct.StoredValue.html#method.with_value" title="method leptos_reactive::StoredValue::with_value"><code>StoredValue::with_value</code></a>.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Disposer.html" title="struct leptos_reactive::Disposer">Disposer</a></div><div class="desc docblock-short">Handle to dispose of a reactive node.</div></li><li><div class="item-name"><a class="struct" href="struct.Effect.html" title="struct leptos_reactive::Effect">Effect</a></div><div class="desc docblock-short">A handle to an effect, can be used to explicitly dispose of the effect.</div></li><li><div class="item-name"><a class="struct" href="struct.FragmentData.html" title="struct leptos_reactive::FragmentData">FragmentData</a></div><div class="desc docblock-short">Represents its pending <code>&lt;Suspense/&gt;</code> fragment.</div></li><li><div class="item-name"><a class="struct" href="struct.MaybeProp.html" title="struct leptos_reactive::MaybeProp">MaybeProp</a></div><div class="desc docblock-short">A wrapping type for an optional component prop, which can either be a signal or a
non-reactive value, and which may or may not have a value. In other words, this is
an <code>Option&lt;MaybeSignal&lt;Option&lt;T&gt;&gt;&gt;</code> that automatically flattens its getters.</div></li><li><div class="item-name"><a class="struct" href="struct.Memo.html" title="struct leptos_reactive::Memo">Memo</a></div><div class="desc docblock-short">An efficient derived reactive value based on other reactive values.</div></li><li><div class="item-name"><a class="struct" href="struct.Owner.html" title="struct leptos_reactive::Owner">Owner</a></div><div class="desc docblock-short">A reactive owner.</div></li><li><div class="item-name"><a class="struct" href="struct.ReadSignal.html" title="struct leptos_reactive::ReadSignal">ReadSignal</a></div><div class="desc docblock-short">The getter for a reactive signal.</div></li><li><div class="item-name"><a class="struct" href="struct.Resource.html" title="struct leptos_reactive::Resource">Resource</a></div><div class="desc docblock-short">A signal that reflects the
current state of an asynchronous task, allowing you to integrate <code>async</code>
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="struct" href="struct.ResourceId.html" title="struct leptos_reactive::ResourceId">ResourceId</a></div><div class="desc docblock-short">Unique ID assigned to a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RuntimeId.html" title="struct leptos_reactive::RuntimeId">RuntimeId</a></div><div class="desc docblock-short">Unique ID assigned to a Runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.RwSignal.html" title="struct leptos_reactive::RwSignal">RwSignal</a></div><div class="desc docblock-short">A signal that combines the getter and setter into one value, rather than
separating them into a <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a> and a <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>. You may prefer this
its style, or it may be easier to pass around in a context or as a function argument.</div></li><li><div class="item-name"><a class="struct" href="struct.ScopedFuture.html" title="struct leptos_reactive::ScopedFuture">ScopedFuture</a></div><div class="desc docblock-short">Allows running a future that has access to a given scope.</div></li><li><div class="item-name"><a class="struct" href="struct.Selector.html" title="struct leptos_reactive::Selector">Selector</a></div><div class="desc docblock-short">A conditional signal that only notifies subscribers when a change
in the source signal’s value changes whether the given function is true.</div></li><li><div class="item-name"><a class="struct" href="struct.Signal.html" title="struct leptos_reactive::Signal">Signal</a></div><div class="desc docblock-short">A wrapper for any kind of readable reactive signal: a <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>, <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, or derived signal closure.</div></li><li><div class="item-name"><a class="struct" href="struct.SignalSetter.html" title="struct leptos_reactive::SignalSetter">SignalSetter</a></div><div class="desc docblock-short">A wrapper for any kind of settable reactive signal: a <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>,
<a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, or closure that receives a value and sets a signal depending
on it.</div></li><li><div class="item-name"><a class="struct" href="struct.StoredValue.html" title="struct leptos_reactive::StoredValue">StoredValue</a></div><div class="desc docblock-short">A <strong>non-reactive</strong> wrapper for any value, which can be created with <a href="fn.store_value.html" title="fn leptos_reactive::store_value"><code>store_value</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Trigger.html" title="struct leptos_reactive::Trigger">Trigger</a></div><div class="desc docblock-short">Reactive Trigger, notifies reactive code to rerun.</div></li><li><div class="item-name"><a class="struct" href="struct.WriteSignal.html" title="struct leptos_reactive::WriteSignal">WriteSignal</a></div><div class="desc docblock-short">The setter for a reactive signal.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.MaybeSignal.html" title="enum leptos_reactive::MaybeSignal">MaybeSignal</a></div><div class="desc docblock-short">A wrapper for a value that is <em>either</em> <code>T</code> or <a href="signal_prelude/prelude/struct.Signal.html" title="struct leptos_reactive::signal_prelude::prelude::Signal"><code>Signal&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.SerializationError.html" title="enum leptos_reactive::SerializationError">SerializationError</a></div><div class="desc docblock-short">Describes errors that can occur while serializing and deserializing data,
typically during the process of streaming <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>s from
the server to the client.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IntoSignal.html" title="trait leptos_reactive::IntoSignal">IntoSignal</a></div><div class="desc docblock-short">Helper trait for converting <code>Fn() -&gt; T</code> closures into
<a href="signal_prelude/prelude/struct.Signal.html" title="struct leptos_reactive::signal_prelude::prelude::Signal"><code>Signal&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoSignalSetter.html" title="trait leptos_reactive::IntoSignalSetter">IntoSignalSetter</a></div><div class="desc docblock-short">Helper trait for converting <code>Fn(T)</code> into <a href="signal_prelude/prelude/struct.SignalSetter.html" title="struct leptos_reactive::signal_prelude::prelude::SignalSetter"><code>SignalSetter&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Serializable.html" title="trait leptos_reactive::Serializable">Serializable</a></div><div class="desc docblock-short">Describes an object that can be serialized to or from a supported format
Currently those are JSON and Cbor</div></li><li><div class="item-name"><a class="trait" href="trait.SignalDispose.html" title="trait leptos_reactive::SignalDispose">SignalDispose</a></div><div class="desc docblock-short">This trait allows disposing a signal before its owner has been disposed.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalGet.html" title="trait leptos_reactive::SignalGet">SignalGet</a></div><div class="desc docblock-short">This trait allows getting an owned value of the signals
inner type.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalGetUntracked.html" title="trait leptos_reactive::SignalGetUntracked">SignalGetUntracked</a></div><div class="desc docblock-short">Trait implemented for all signal types which you can <code>get</code> a value
from, such as <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>, etc., which allows getting the inner value without
subscribing to the current scope.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalSet.html" title="trait leptos_reactive::SignalSet">SignalSet</a></div><div class="desc docblock-short">This trait allows setting the value of a signal.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalSetUntracked.html" title="trait leptos_reactive::SignalSetUntracked">SignalSetUntracked</a></div><div class="desc docblock-short">Trait implemented for all signal types which you can <code>set</code> the inner
value, such as <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a> and <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, which allows setting
the inner value without causing effects which depend on the signal
from being run.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalStream.html" title="trait leptos_reactive::SignalStream">SignalStream</a></div><div class="desc docblock-short">This trait allows converting a signal into a async <a href="../futures_core/stream/trait.Stream.html" title="trait futures_core::stream::Stream"><code>Stream</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalUpdate.html" title="trait leptos_reactive::SignalUpdate">SignalUpdate</a></div><div class="desc docblock-short">This trait allows updating the inner value of a signal.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalUpdateUntracked.html" title="trait leptos_reactive::SignalUpdateUntracked">SignalUpdateUntracked</a></div><div class="desc docblock-short">This trait allows updating the signals value without causing
dependant effects to run.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalWith.html" title="trait leptos_reactive::SignalWith">SignalWith</a></div><div class="desc docblock-short">This trait allows obtaining an immutable reference to the signal’s
inner type.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalWithUntracked.html" title="trait leptos_reactive::SignalWithUntracked">SignalWithUntracked</a></div><div class="desc docblock-short">This trait allows getting a reference to the signals inner value
without creating a dependency on the signal.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.as_child_of_current_owner.html" title="fn leptos_reactive::as_child_of_current_owner">as_child_of_current_owner</a></div><div class="desc docblock-short">Wraps the given function so that, whenever it is called, it creates
a child node owned by whichever reactive node was the owner
when it was created, runs the function, and returns a disposer that
can be used to dispose of the child later.</div></li><li><div class="item-name"><a class="fn" href="fn.batch.html" title="fn leptos_reactive::batch">batch</a></div><div class="desc docblock-short">Batches any reactive updates, preventing effects from running until the whole
function has run. This allows you to prevent rerunning effects if multiple
signal updates might cause the same effect to run.</div></li><li><div class="item-name"><a class="fn" href="fn.create_blocking_resource.html" title="fn leptos_reactive::create_blocking_resource">create_blocking_resource</a></div><div class="desc docblock-short">Creates a “blocking” <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>. When server-side rendering is used,
this resource will cause any <code>&lt;Suspense/&gt;</code> you read it under to block the initial
chunk of HTML from being sent to the client. This means that if you set things like
HTTP headers or <code>&lt;head&gt;</code> metadata in that <code>&lt;Suspense/&gt;</code>, that header material will
be included in the server’s original response.</div></li><li><div class="item-name"><a class="fn" href="fn.create_effect.html" title="fn leptos_reactive::create_effect">create_effect</a></div><div class="desc docblock-short">Effects run a certain chunk of code whenever the signals they depend on change.
<code>create_effect</code> queues the given function to run once, tracks its dependence
on any signal values read within it, and reruns the function whenever the value
of a dependency changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_isomorphic_effect.html" title="fn leptos_reactive::create_isomorphic_effect">create_isomorphic_effect</a></div><div class="desc docblock-short">Creates an effect; unlike effects created by <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a>, isomorphic effects will run on
the server as well as the client.</div></li><li><div class="item-name"><a class="fn" href="fn.create_local_resource.html" title="fn leptos_reactive::create_local_resource">create_local_resource</a></div><div class="desc docblock-short">Creates a <em>local</em> <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>, which is a signal that
reflects the current state of an asynchronous task, allowing you to
integrate <code>async</code> <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.create_local_resource_with_initial_value.html" title="fn leptos_reactive::create_local_resource_with_initial_value">create_local_resource_with_initial_value</a></div><div class="desc docblock-short">Creates a <em>local</em> <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> with the given initial value,
which will only generate and run a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> using the <code>fetcher</code> when the
<code>source</code> changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_memo.html" title="fn leptos_reactive::create_memo">create_memo</a></div><div class="desc docblock-short">Creates an efficient derived reactive value based on other reactive values.</div></li><li><div class="item-name"><a class="fn" href="fn.create_read_slice.html" title="fn leptos_reactive::create_read_slice">create_read_slice</a></div><div class="desc docblock-short">Takes a memoized, read-only slice of a signal. This is equivalent to the
read-only half of <a href="fn.create_slice.html" title="fn leptos_reactive::create_slice"><code>create_slice</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_render_effect.html" title="fn leptos_reactive::create_render_effect">create_render_effect</a></div><div class="desc docblock-short">Creates an effect exactly like <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a>, but runs immediately rather
than being queued until the end of the current microtask. This is mostly used
inside the renderer but is available for use cases in which scheduling the effect
for the next tick is not optimal.</div></li><li><div class="item-name"><a class="fn" href="fn.create_resource.html" title="fn leptos_reactive::create_resource">create_resource</a></div><div class="desc docblock-short">Creates a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>, which is a signal that reflects the
current state of an asynchronous task, allowing you to integrate <code>async</code>
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.create_resource_with_initial_value.html" title="fn leptos_reactive::create_resource_with_initial_value">create_resource_with_initial_value</a></div><div class="desc docblock-short">Creates a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> with the given initial value, which
will only generate and run a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> using the <code>fetcher</code> when the <code>source</code> changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_runtime.html" title="fn leptos_reactive::create_runtime">create_runtime</a></div><div class="desc docblock-short">Creates a new reactive runtime and sets it as the current runtime.</div></li><li><div class="item-name"><a class="fn" href="fn.create_rw_signal.html" title="fn leptos_reactive::create_rw_signal">create_rw_signal</a></div><div class="desc docblock-short">Creates a reactive signal with the getter and setter unified in one value.
You may prefer this style, or it may be easier to pass around in a context
or as a function argument.</div></li><li><div class="item-name"><a class="fn" href="fn.create_selector.html" title="fn leptos_reactive::create_selector">create_selector</a></div><div class="desc docblock-short">Creates a conditional signal that only notifies subscribers when a change
in the source signal’s value changes whether it is equal to the key value
(as determined by <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a>.)</div></li><li><div class="item-name"><a class="fn" href="fn.create_selector_with_fn.html" title="fn leptos_reactive::create_selector_with_fn">create_selector_with_fn</a></div><div class="desc docblock-short">Creates a conditional signal that only notifies subscribers when a change
in the source signal’s value changes whether the given function is true.</div></li><li><div class="item-name"><a class="fn" href="fn.create_signal.html" title="fn leptos_reactive::create_signal">create_signal</a></div><div class="desc docblock-short">Creates a signal, the basic reactive primitive.</div></li><li><div class="item-name"><a class="fn" href="fn.create_signal_from_stream.html" title="fn leptos_reactive::create_signal_from_stream">create_signal_from_stream</a></div><div class="desc docblock-short">Creates a signal that always contains the most recent value emitted by a
<a href="../futures_core/stream/trait.Stream.html" title="trait futures_core::stream::Stream"><code>Stream</code></a>.
If the stream has not yet emitted a value since the signal was created, the signal’s
value will be <code>None</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_slice.html" title="fn leptos_reactive::create_slice">create_slice</a></div><div class="desc docblock-short">Derives a reactive slice of an <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_trigger.html" title="fn leptos_reactive::create_trigger">create_trigger</a></div><div class="desc docblock-short">Creates a <a href="struct.Trigger.html" title="struct leptos_reactive::Trigger"><code>Trigger</code></a>, a kind of reactive primitive.</div></li><li><div class="item-name"><a class="fn" href="fn.create_write_slice.html" title="fn leptos_reactive::create_write_slice">create_write_slice</a></div><div class="desc docblock-short">Creates a setter to access one slice of a signal. This is equivalent to the
write-only half of <a href="fn.create_slice.html" title="fn leptos_reactive::create_slice"><code>create_slice</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.current_runtime.html" title="fn leptos_reactive::current_runtime">current_runtime</a></div><div class="desc docblock-short">The current reactive runtime.</div></li><li><div class="item-name"><a class="fn" href="fn.expect_context.html" title="fn leptos_reactive::expect_context">expect_context</a></div><div class="desc docblock-short">Extracts a context value of type <code>T</code> from the reactive system by traversing
it upwards, beginning from the current reactive owner and iterating
through its parents, if any. The context value should have been provided elsewhere
using <a href="fn.provide_context.html" title="fn leptos_reactive::provide_context">provide_context</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.on_cleanup.html" title="fn leptos_reactive::on_cleanup">on_cleanup</a></div><div class="desc docblock-short">Creates a cleanup function, which will be run when the current reactive owner is disposed.</div></li><li><div class="item-name"><a class="fn" href="fn.provide_context.html" title="fn leptos_reactive::provide_context">provide_context</a></div><div class="desc docblock-short">Provides a context value of type <code>T</code> to the current reactive node
and all of its descendants. This can be consumed using <a href="fn.use_context.html" title="fn leptos_reactive::use_context"><code>use_context</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.queue_microtask.html" title="fn leptos_reactive::queue_microtask">queue_microtask</a></div><div class="desc docblock-short">The microtask is a short function which will run after the current task has
completed its work and when there is no other code waiting to be run before
control of the execution context is returned to the browser’s event loop.</div></li><li><div class="item-name"><a class="fn" href="fn.run_as_child.html" title="fn leptos_reactive::run_as_child">run_as_child</a></div><div class="desc docblock-short">Runs the given function as a child of the current Owner, once.</div></li><li><div class="item-name"><a class="fn" href="fn.set_current_runtime.html" title="fn leptos_reactive::set_current_runtime">set_current_runtime</a></div><div class="desc docblock-short">Sets the current reactive runtime.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn_local.html" title="fn leptos_reactive::spawn_local">spawn_local</a></div><div class="desc docblock-short">Spawns and runs a thread-local <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> in a platform-independent way.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn_local_with_current_owner.html" title="fn leptos_reactive::spawn_local_with_current_owner">spawn_local_with_current_owner</a></div><div class="desc docblock-short">Runs a future that has access to the provided <a href="struct.Owner.html" title="struct leptos_reactive::Owner"><code>Owner</code></a>’s
scope context.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn_local_with_owner.html" title="fn leptos_reactive::spawn_local_with_owner">spawn_local_with_owner</a></div><div class="desc docblock-short">Runs a future that has access to the provided <a href="struct.Owner.html" title="struct leptos_reactive::Owner"><code>Owner</code></a>’s
scope context.</div></li><li><div class="item-name"><a class="fn" href="fn.store_value.html" title="fn leptos_reactive::store_value">store_value</a></div><div class="desc docblock-short">Creates a <strong>non-reactive</strong> wrapper for any value by storing it within
the reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.try_spawn_local_with_current_owner.html" title="fn leptos_reactive::try_spawn_local_with_current_owner">try_spawn_local_with_current_owner</a></div><div class="desc docblock-short">Runs a future that has access to the provided <a href="struct.Owner.html" title="struct leptos_reactive::Owner"><code>Owner</code></a>’s
scope context.</div></li><li><div class="item-name"><a class="fn" href="fn.try_spawn_local_with_owner.html" title="fn leptos_reactive::try_spawn_local_with_owner">try_spawn_local_with_owner</a></div><div class="desc docblock-short">Runs a future that has access to the provided <a href="struct.Owner.html" title="struct leptos_reactive::Owner"><code>Owner</code></a>’s
scope context.</div></li><li><div class="item-name"><a class="fn" href="fn.try_with_owner.html" title="fn leptos_reactive::try_with_owner">try_with_owner</a></div><div class="desc docblock-short">Runs the given code with the given reactive owner.</div></li><li><div class="item-name"><a class="fn" href="fn.untrack.html" title="fn leptos_reactive::untrack">untrack</a></div><div class="desc docblock-short">Suspends reactive tracking while running the given function.</div></li><li><div class="item-name"><a class="fn" href="fn.use_context.html" title="fn leptos_reactive::use_context">use_context</a></div><div class="desc docblock-short">Extracts a context value of type <code>T</code> from the reactive system by traversing
it upwards, beginning from the current reactive owner and iterating
through its parents, if any. The context value should have been provided elsewhere
using <a href="fn.provide_context.html" title="fn leptos_reactive::provide_context"><code>provide_context</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.watch.html" title="fn leptos_reactive::watch">watch</a></div><div class="desc docblock-short">A version of <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a> that listens to any dependency
that is accessed inside <code>deps</code> and returns a stop handler.</div></li><li><div class="item-name"><a class="fn" href="fn.with_current_owner.html" title="fn leptos_reactive::with_current_owner">with_current_owner</a></div><div class="desc docblock-short">Wraps the given function so that, whenever it is called, it is run
in the reactive scope of whatever the reactive owner was when it was
created.</div></li><li><div class="item-name"><a class="fn" href="fn.with_owner.html" title="fn leptos_reactive::with_owner">with_owner</a></div><div class="desc docblock-short">Runs the given code with the given reactive owner.</div></li></ul></section></div></main></body></html>